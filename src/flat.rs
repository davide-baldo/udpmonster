// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Command {
  NONE = 0,
  Create = 1,
  Drop = 2,
  Insert = 3,
  Delete = 4,
  Query = 5,
  Update = 6,

}

const ENUM_MIN_COMMAND: u8 = 0;
const ENUM_MAX_COMMAND: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for Command {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Command {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Command;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Command {
    type Output = Command;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Command>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COMMAND:[Command; 7] = [
  Command::NONE,
  Command::Create,
  Command::Drop,
  Command::Insert,
  Command::Delete,
  Command::Query,
  Command::Update
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COMMAND:[&'static str; 7] = [
    "NONE",
    "Create",
    "Drop",
    "Insert",
    "Delete",
    "Query",
    "Update"
];

pub fn enum_name_command(e: Command) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_COMMAND[index as usize]
}

pub struct CommandUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum CommandResponse {
  NONE = 0,
  Create = 1,
  Drop = 2,
  Insert = 3,
  Delete = 4,
  Query = 5,
  Update = 6,

}

const ENUM_MIN_COMMAND_RESPONSE: u8 = 0;
const ENUM_MAX_COMMAND_RESPONSE: u8 = 6;

impl<'a> flatbuffers::Follow<'a> for CommandResponse {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for CommandResponse {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const CommandResponse;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const CommandResponse;
    unsafe { *p }
  }
}

impl flatbuffers::Push for CommandResponse {
    type Output = CommandResponse;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<CommandResponse>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_COMMAND_RESPONSE:[CommandResponse; 7] = [
  CommandResponse::NONE,
  CommandResponse::Create,
  CommandResponse::Drop,
  CommandResponse::Insert,
  CommandResponse::Delete,
  CommandResponse::Query,
  CommandResponse::Update
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_COMMAND_RESPONSE:[&'static str; 7] = [
    "NONE",
    "Create",
    "Drop",
    "Insert",
    "Delete",
    "Query",
    "Update"
];

pub fn enum_name_command_response(e: CommandResponse) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_COMMAND_RESPONSE[index as usize]
}

pub struct CommandResponseUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Sort {
  None = 0,
  Asc = 1,
  Desc = 2,

}

const ENUM_MIN_SORT: i8 = 0;
const ENUM_MAX_SORT: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for Sort {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Sort {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const Sort;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const Sort;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Sort {
    type Output = Sort;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Sort>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_SORT:[Sort; 3] = [
  Sort::None,
  Sort::Asc,
  Sort::Desc
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_SORT:[&'static str; 3] = [
    "None",
    "Asc",
    "Desc"
];

pub fn enum_name_sort(e: Sort) -> &'static str {
  let index = e as i8;
  ENUM_NAMES_SORT[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FilterType {
  None = 0,
  Equal = 1,
  Different = 2,
  OperatorBigger = 3,
  Smaller = 4,
  BiggerEq = 5,
  SmallerEq = 6,
  LogicalAnd = 7,
  LogicalOr = 8,
  LogicalNot = 9,

}

const ENUM_MIN_FILTER_TYPE: u8 = 0;
const ENUM_MAX_FILTER_TYPE: u8 = 9;

impl<'a> flatbuffers::Follow<'a> for FilterType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FilterType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FilterType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FilterType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FilterType {
    type Output = FilterType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FilterType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILTER_TYPE:[FilterType; 10] = [
  FilterType::None,
  FilterType::Equal,
  FilterType::Different,
  FilterType::OperatorBigger,
  FilterType::Smaller,
  FilterType::BiggerEq,
  FilterType::SmallerEq,
  FilterType::LogicalAnd,
  FilterType::LogicalOr,
  FilterType::LogicalNot
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILTER_TYPE:[&'static str; 10] = [
    "None",
    "Equal",
    "Different",
    "OperatorBigger",
    "Smaller",
    "BiggerEq",
    "SmallerEq",
    "LogicalAnd",
    "LogicalOr",
    "LogicalNot"
];

pub fn enum_name_filter_type(e: FilterType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FILTER_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FilterValue {
  NONE = 0,
  immediate = 1,
  reference = 2,
  filter = 3,

}

const ENUM_MIN_FILTER_VALUE: u8 = 0;
const ENUM_MAX_FILTER_VALUE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for FilterValue {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FilterValue {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FilterValue;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FilterValue;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FilterValue {
    type Output = FilterValue;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FilterValue>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILTER_VALUE:[FilterValue; 4] = [
  FilterValue::NONE,
  FilterValue::immediate,
  FilterValue::reference,
  FilterValue::filter
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILTER_VALUE:[&'static str; 4] = [
    "NONE",
    "immediate",
    "reference",
    "filter"
];

pub fn enum_name_filter_value(e: FilterValue) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FILTER_VALUE[index as usize]
}

pub struct FilterValueUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum FieldType {
  Blob = 0,
  UInt64 = 1,

}

const ENUM_MIN_FIELD_TYPE: u8 = 0;
const ENUM_MAX_FIELD_TYPE: u8 = 1;

impl<'a> flatbuffers::Follow<'a> for FieldType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FieldType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FieldType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FieldType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FieldType {
    type Output = FieldType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FieldType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FIELD_TYPE:[FieldType; 2] = [
  FieldType::Blob,
  FieldType::UInt64
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FIELD_TYPE:[&'static str; 2] = [
    "Blob",
    "UInt64"
];

pub fn enum_name_field_type(e: FieldType) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_FIELD_TYPE[index as usize]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum UpdateValue {
  NONE = 0,
  immediate = 1,
  reference = 2,

}

const ENUM_MIN_UPDATE_VALUE: u8 = 0;
const ENUM_MAX_UPDATE_VALUE: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for UpdateValue {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for UpdateValue {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const UpdateValue;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const UpdateValue;
    unsafe { *p }
  }
}

impl flatbuffers::Push for UpdateValue {
    type Output = UpdateValue;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<UpdateValue>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_UPDATE_VALUE:[UpdateValue; 3] = [
  UpdateValue::NONE,
  UpdateValue::immediate,
  UpdateValue::reference
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_UPDATE_VALUE:[&'static str; 3] = [
    "NONE",
    "immediate",
    "reference"
];

pub fn enum_name_update_value(e: UpdateValue) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_UPDATE_VALUE[index as usize]
}

pub struct UpdateValueUnionTableOffset {}
pub enum EmptyCommandResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EmptyCommandResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EmptyCommandResponse<'a> {
    type Inner = EmptyCommandResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EmptyCommandResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EmptyCommandResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        _args: &'args EmptyCommandResponseArgs) -> flatbuffers::WIPOffset<EmptyCommandResponse<'bldr>> {
      let mut builder = EmptyCommandResponseBuilder::new(_fbb);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<EmptyCommandResponse<'wr_to>> {
      let mut builder = EmptyCommandResponseBuilder::new(_fbb);
      builder.finish()
    }

}

pub struct EmptyCommandResponseArgs {
}
impl<'a> Default for EmptyCommandResponseArgs {
    #[inline]
    fn default() -> Self {
        EmptyCommandResponseArgs {
        }
    }
}
pub struct EmptyCommandResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EmptyCommandResponseBuilder<'a, 'b> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EmptyCommandResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EmptyCommandResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EmptyCommandResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum QueryRowResponseOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct QueryRowResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryRowResponse<'a> {
    type Inner = QueryRowResponse<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> QueryRowResponse<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        QueryRowResponse {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args QueryRowResponseArgs<'args>) -> flatbuffers::WIPOffset<QueryRowResponse<'bldr>> {
      let mut builder = QueryRowResponseBuilder::new(_fbb);
      if let Some(x) = args.rows { builder.add_rows(x); }
      builder.add_index(args.index);
      builder.add_last(args.last);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<QueryRowResponse<'wr_to>> {
      let rows =  { match self.rows() { Some(u) => Some({ let mut tmp = vec!(); for x in u { tmp.push(x.write_to(_fbb)) }  let tmp_len = tmp.len();  _fbb.start_vector::<flatbuffers::WIPOffset<QueryRowResponse>>(tmp_len);    for x in tmp { _fbb.push(x); }  _fbb.end_vector(tmp_len)}), _ => None } };
      let index = self.index();
      let last = self.last();
      let mut builder = QueryRowResponseBuilder::new(_fbb);
      if let Some(u) = rows { builder.add_rows(u); } 
      builder.add_index(index);
      builder.add_last(last);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;
    pub const VT_ROWS: flatbuffers::VOffsetT = 6;
    pub const VT_LAST: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn index(&self) -> u32 {
    self._tab.get::<u32>(QueryRowResponse::VT_INDEX, Some(0)).unwrap()
  }
  #[inline]
  pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Row<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Row<'a>>>>>(QueryRowResponse::VT_ROWS, None)
  }
  #[inline]
  pub fn last(&self) -> bool {
    self._tab.get::<bool>(QueryRowResponse::VT_LAST, Some(false)).unwrap()
  }
}

pub struct QueryRowResponseArgs<'a> {
    pub index: u32,
    pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Row<'a >>>>>,
    pub last: bool,
}
impl<'a> Default for QueryRowResponseArgs<'a> {
    #[inline]
    fn default() -> Self {
        QueryRowResponseArgs {
            index: 0,
            rows: None,
            last: false,
        }
    }
}
pub struct QueryRowResponseBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryRowResponseBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u32) {
    self.fbb_.push_slot::<u32>(QueryRowResponse::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Row<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(QueryRowResponse::VT_ROWS, rows);
  }
  #[inline]
  pub fn add_last(&mut self, last: bool) {
    self.fbb_.push_slot::<bool>(QueryRowResponse::VT_LAST, last, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryRowResponseBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryRowResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryRowResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum PacketOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Packet<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Packet<'a> {
    type Inner = Packet<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Packet<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Packet {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PacketArgs) -> flatbuffers::WIPOffset<Packet<'bldr>> {
      let mut builder = PacketBuilder::new(_fbb);
      if let Some(x) = args.command { builder.add_command(x); }
      builder.add_crc(args.crc);
      builder.add_timeout(args.timeout);
      builder.add_version(args.version);
      builder.add_command_type(args.command_type);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<Packet<'wr_to>> {
      let command = self.command_write_to(_fbb);
      let crc = self.crc();
      let timeout = self.timeout();
      let version = self.version();
      let command_type = self.command_type();
      let mut builder = PacketBuilder::new(_fbb);
      command.map(|u| builder.add_command(u));
      builder.add_crc(crc);
      builder.add_timeout(timeout);
      builder.add_version(version);
      builder.add_command_type(command_type);
      builder.finish()
    }

    pub const VT_CRC: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_TIMEOUT: flatbuffers::VOffsetT = 8;
    pub const VT_COMMAND_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_COMMAND: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn crc(&self) -> u32 {
    self._tab.get::<u32>(Packet::VT_CRC, Some(0)).unwrap()
  }
  #[inline]
  pub fn version(&self) -> u16 {
    self._tab.get::<u16>(Packet::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn timeout(&self) -> u16 {
    self._tab.get::<u16>(Packet::VT_TIMEOUT, Some(0)).unwrap()
  }
  #[inline]
  pub fn command_type(&self) -> Command {
    self._tab.get::<Command>(Packet::VT_COMMAND_TYPE, Some(Command::NONE)).unwrap()
  }
  #[inline]
  pub fn command(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Packet::VT_COMMAND, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_create(&self) -> Option<CreateCommand<'a>> {
    if self.command_type() == Command::Create {
      Some(CreateCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_drop(&self) -> Option<DropCommand<'a>> {
    if self.command_type() == Command::Drop {
      Some(DropCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_insert(&self) -> Option<InsertCommand<'a>> {
    if self.command_type() == Command::Insert {
      Some(InsertCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_delete(&self) -> Option<DeleteCommand<'a>> {
    if self.command_type() == Command::Delete {
      Some(DeleteCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_query(&self) -> Option<QueryCommand<'a>> {
    if self.command_type() == Command::Query {
      Some(QueryCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_as_update(&self) -> Option<UpdateCommand<'a>> {
    if self.command_type() == Command::Update {
      Some(UpdateCommand::init_from_table( self.command()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn command_write_to<'wr_to>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    if self.command_type() == Command::Create {
      return Some(CreateCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    if self.command_type() == Command::Drop {
      return Some(DropCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    if self.command_type() == Command::Insert {
      return Some(InsertCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    if self.command_type() == Command::Delete {
      return Some(DeleteCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    if self.command_type() == Command::Query {
      return Some(QueryCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    if self.command_type() == Command::Update {
      return Some(UpdateCommand::init_from_table(self.command()).write_to(_fbb).as_union_value());
    }
    None
  }

}

pub struct PacketArgs {
    pub crc: u32,
    pub version: u16,
    pub timeout: u16,
    pub command_type: Command,
    pub command: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for PacketArgs {
    #[inline]
    fn default() -> Self {
        PacketArgs {
            crc: 0,
            version: 0,
            timeout: 0,
            command_type: Command::NONE,
            command: None, // required field
        }
    }
}
pub struct PacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_crc(&mut self, crc: u32) {
    self.fbb_.push_slot::<u32>(Packet::VT_CRC, crc, 0);
  }
  #[inline]
  pub fn add_version(&mut self, version: u16) {
    self.fbb_.push_slot::<u16>(Packet::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_timeout(&mut self, timeout: u16) {
    self.fbb_.push_slot::<u16>(Packet::VT_TIMEOUT, timeout, 0);
  }
  #[inline]
  pub fn add_command_type(&mut self, command_type: Command) {
    self.fbb_.push_slot::<Command>(Packet::VT_COMMAND_TYPE, command_type, Command::NONE);
  }
  #[inline]
  pub fn add_command(&mut self, command: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Packet::VT_COMMAND, command);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Packet<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Packet::VT_COMMAND,"command");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ResponsePacketOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct ResponsePacket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ResponsePacket<'a> {
    type Inner = ResponsePacket<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> ResponsePacket<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ResponsePacket {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ResponsePacketArgs) -> flatbuffers::WIPOffset<ResponsePacket<'bldr>> {
      let mut builder = ResponsePacketBuilder::new(_fbb);
      if let Some(x) = args.response { builder.add_response(x); }
      builder.add_crc(args.crc);
      builder.add_version(args.version);
      builder.add_response_type(args.response_type);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<ResponsePacket<'wr_to>> {
      let response = self.response_write_to(_fbb);
      let crc = self.crc();
      let version = self.version();
      let response_type = self.response_type();
      let mut builder = ResponsePacketBuilder::new(_fbb);
      response.map(|u| builder.add_response(u));
      builder.add_crc(crc);
      builder.add_version(version);
      builder.add_response_type(response_type);
      builder.finish()
    }

    pub const VT_CRC: flatbuffers::VOffsetT = 4;
    pub const VT_VERSION: flatbuffers::VOffsetT = 6;
    pub const VT_RESPONSE_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_RESPONSE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn crc(&self) -> u32 {
    self._tab.get::<u32>(ResponsePacket::VT_CRC, Some(0)).unwrap()
  }
  #[inline]
  pub fn version(&self) -> u16 {
    self._tab.get::<u16>(ResponsePacket::VT_VERSION, Some(0)).unwrap()
  }
  #[inline]
  pub fn response_type(&self) -> CommandResponse {
    self._tab.get::<CommandResponse>(ResponsePacket::VT_RESPONSE_TYPE, Some(CommandResponse::NONE)).unwrap()
  }
  #[inline]
  pub fn response(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ResponsePacket::VT_RESPONSE, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_create(&self) -> Option<EmptyCommandResponse<'a>> {
    if self.response_type() == CommandResponse::Create {
      Some(EmptyCommandResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_drop(&self) -> Option<EmptyCommandResponse<'a>> {
    if self.response_type() == CommandResponse::Drop {
      Some(EmptyCommandResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_insert(&self) -> Option<EmptyCommandResponse<'a>> {
    if self.response_type() == CommandResponse::Insert {
      Some(EmptyCommandResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_delete(&self) -> Option<EmptyCommandResponse<'a>> {
    if self.response_type() == CommandResponse::Delete {
      Some(EmptyCommandResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_query(&self) -> Option<QueryRowResponse<'a>> {
    if self.response_type() == CommandResponse::Query {
      Some(QueryRowResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_as_update(&self) -> Option<EmptyCommandResponse<'a>> {
    if self.response_type() == CommandResponse::Update {
      Some(EmptyCommandResponse::init_from_table( self.response()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn response_write_to<'wr_to>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    if self.response_type() == CommandResponse::Create {
      return Some(EmptyCommandResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    if self.response_type() == CommandResponse::Drop {
      return Some(EmptyCommandResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    if self.response_type() == CommandResponse::Insert {
      return Some(EmptyCommandResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    if self.response_type() == CommandResponse::Delete {
      return Some(EmptyCommandResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    if self.response_type() == CommandResponse::Query {
      return Some(QueryRowResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    if self.response_type() == CommandResponse::Update {
      return Some(EmptyCommandResponse::init_from_table(self.response()).write_to(_fbb).as_union_value());
    }
    None
  }

}

pub struct ResponsePacketArgs {
    pub crc: u32,
    pub version: u16,
    pub response_type: CommandResponse,
    pub response: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ResponsePacketArgs {
    #[inline]
    fn default() -> Self {
        ResponsePacketArgs {
            crc: 0,
            version: 0,
            response_type: CommandResponse::NONE,
            response: None, // required field
        }
    }
}
pub struct ResponsePacketBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ResponsePacketBuilder<'a, 'b> {
  #[inline]
  pub fn add_crc(&mut self, crc: u32) {
    self.fbb_.push_slot::<u32>(ResponsePacket::VT_CRC, crc, 0);
  }
  #[inline]
  pub fn add_version(&mut self, version: u16) {
    self.fbb_.push_slot::<u16>(ResponsePacket::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_response_type(&mut self, response_type: CommandResponse) {
    self.fbb_.push_slot::<CommandResponse>(ResponsePacket::VT_RESPONSE_TYPE, response_type, CommandResponse::NONE);
  }
  #[inline]
  pub fn add_response(&mut self, response: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ResponsePacket::VT_RESPONSE, response);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ResponsePacketBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ResponsePacketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ResponsePacket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ResponsePacket::VT_RESPONSE,"response");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FilterOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Filter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Filter<'a> {
    type Inner = Filter<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Filter<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Filter {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FilterArgs) -> flatbuffers::WIPOffset<Filter<'bldr>> {
      let mut builder = FilterBuilder::new(_fbb);
      if let Some(x) = args.right_value { builder.add_right_value(x); }
      if let Some(x) = args.left_value { builder.add_left_value(x); }
      builder.add_right_value_type(args.right_value_type);
      builder.add_left_value_type(args.left_value_type);
      builder.add_type_(args.type_);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<Filter<'wr_to>> {
      let right_value = self.right_value_write_to(_fbb);
      let left_value = self.left_value_write_to(_fbb);
      let right_value_type = self.right_value_type();
      let left_value_type = self.left_value_type();
      let type_ = self.type_();
      let mut builder = FilterBuilder::new(_fbb);
      right_value.map(|u| builder.add_right_value(u));
      left_value.map(|u| builder.add_left_value(u));
      builder.add_right_value_type(right_value_type);
      builder.add_left_value_type(left_value_type);
      builder.add_type_(type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT_VALUE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_LEFT_VALUE: flatbuffers::VOffsetT = 8;
    pub const VT_RIGHT_VALUE_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_RIGHT_VALUE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn type_(&self) -> FilterType {
    self._tab.get::<FilterType>(Filter::VT_TYPE_, Some(FilterType::None)).unwrap()
  }
  #[inline]
  pub fn left_value_type(&self) -> FilterValue {
    self._tab.get::<FilterValue>(Filter::VT_LEFT_VALUE_TYPE, Some(FilterValue::NONE)).unwrap()
  }
  #[inline]
  pub fn left_value(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Filter::VT_LEFT_VALUE, None)
  }
  #[inline]
  pub fn right_value_type(&self) -> FilterValue {
    self._tab.get::<FilterValue>(Filter::VT_RIGHT_VALUE_TYPE, Some(FilterValue::NONE)).unwrap()
  }
  #[inline]
  pub fn right_value(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Filter::VT_RIGHT_VALUE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn left_value_as_immediate(&self) -> Option<Immediate<'a>> {
    if self.left_value_type() == FilterValue::immediate {
      self.left_value().map(|u| Immediate::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_value_as_reference(&self) -> Option<TableReference<'a>> {
    if self.left_value_type() == FilterValue::reference {
      self.left_value().map(|u| TableReference::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_value_as_filter(&self) -> Option<Filter<'a>> {
    if self.left_value_type() == FilterValue::filter {
      self.left_value().map(|u| Filter::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn left_value_write_to<'wr_to>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    if self.left_value_type() == FilterValue::immediate {
      return self.left_value().map(|u| Immediate::init_from_table(u).write_to(_fbb).as_union_value());
    }
    if self.left_value_type() == FilterValue::reference {
      return self.left_value().map(|u| TableReference::init_from_table(u).write_to(_fbb).as_union_value());
    }
    if self.left_value_type() == FilterValue::filter {
      return self.left_value().map(|u| Filter::init_from_table(u).write_to(_fbb).as_union_value());
    }
    None
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_value_as_immediate(&self) -> Option<Immediate<'a>> {
    if self.right_value_type() == FilterValue::immediate {
      self.right_value().map(|u| Immediate::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_value_as_reference(&self) -> Option<TableReference<'a>> {
    if self.right_value_type() == FilterValue::reference {
      self.right_value().map(|u| TableReference::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_value_as_filter(&self) -> Option<Filter<'a>> {
    if self.right_value_type() == FilterValue::filter {
      self.right_value().map(|u| Filter::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn right_value_write_to<'wr_to>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    if self.right_value_type() == FilterValue::immediate {
      return self.right_value().map(|u| Immediate::init_from_table(u).write_to(_fbb).as_union_value());
    }
    if self.right_value_type() == FilterValue::reference {
      return self.right_value().map(|u| TableReference::init_from_table(u).write_to(_fbb).as_union_value());
    }
    if self.right_value_type() == FilterValue::filter {
      return self.right_value().map(|u| Filter::init_from_table(u).write_to(_fbb).as_union_value());
    }
    None
  }

}

pub struct FilterArgs {
    pub type_: FilterType,
    pub left_value_type: FilterValue,
    pub left_value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub right_value_type: FilterValue,
    pub right_value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FilterArgs {
    #[inline]
    fn default() -> Self {
        FilterArgs {
            type_: FilterType::None,
            left_value_type: FilterValue::NONE,
            left_value: None,
            right_value_type: FilterValue::NONE,
            right_value: None,
        }
    }
}
pub struct FilterBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FilterBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: FilterType) {
    self.fbb_.push_slot::<FilterType>(Filter::VT_TYPE_, type_, FilterType::None);
  }
  #[inline]
  pub fn add_left_value_type(&mut self, left_value_type: FilterValue) {
    self.fbb_.push_slot::<FilterValue>(Filter::VT_LEFT_VALUE_TYPE, left_value_type, FilterValue::NONE);
  }
  #[inline]
  pub fn add_left_value(&mut self, left_value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_LEFT_VALUE, left_value);
  }
  #[inline]
  pub fn add_right_value_type(&mut self, right_value_type: FilterValue) {
    self.fbb_.push_slot::<FilterValue>(Filter::VT_RIGHT_VALUE_TYPE, right_value_type, FilterValue::NONE);
  }
  #[inline]
  pub fn add_right_value(&mut self, right_value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Filter::VT_RIGHT_VALUE, right_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FilterBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Filter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TableReferenceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TableReference<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableReference<'a> {
    type Inner = TableReference<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TableReference<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TableReference {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TableReferenceArgs) -> flatbuffers::WIPOffset<TableReference<'bldr>> {
      let mut builder = TableReferenceBuilder::new(_fbb);
      builder.add_table_id(args.table_id);
      builder.add_field_id(args.field_id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<TableReference<'wr_to>> {
      let table_id = self.table_id();
      let field_id = self.field_id();
      let mut builder = TableReferenceBuilder::new(_fbb);
      builder.add_table_id(table_id);
      builder.add_field_id(field_id);
      builder.finish()
    }

    pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FIELD_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn table_id(&self) -> u16 {
    self._tab.get::<u16>(TableReference::VT_TABLE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn field_id(&self) -> u8 {
    self._tab.get::<u8>(TableReference::VT_FIELD_ID, Some(0)).unwrap()
  }
}

pub struct TableReferenceArgs {
    pub table_id: u16,
    pub field_id: u8,
}
impl<'a> Default for TableReferenceArgs {
    #[inline]
    fn default() -> Self {
        TableReferenceArgs {
            table_id: 0,
            field_id: 0,
        }
    }
}
pub struct TableReferenceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TableReferenceBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: u16) {
    self.fbb_.push_slot::<u16>(TableReference::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_field_id(&mut self, field_id: u8) {
    self.fbb_.push_slot::<u8>(TableReference::VT_FIELD_ID, field_id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableReferenceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TableReferenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableReference<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum CreateCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct CreateCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CreateCommand<'a> {
    type Inner = CreateCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> CreateCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        CreateCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args CreateCommandArgs<'args>) -> flatbuffers::WIPOffset<CreateCommand<'bldr>> {
      let mut builder = CreateCommandBuilder::new(_fbb);
      if let Some(x) = args.engine { builder.add_engine(x); }
      if let Some(x) = args.schema { builder.add_schema(x); }
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<CreateCommand<'wr_to>> {
      let engine = _fbb.create_string(self.engine());
      let schema = self.schema().write_to(_fbb);
      let mut builder = CreateCommandBuilder::new(_fbb);
      builder.add_engine(engine);
      builder.add_schema(schema);
      builder.finish()
    }

    pub const VT_SCHEMA: flatbuffers::VOffsetT = 4;
    pub const VT_ENGINE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn schema(&self) -> TableSchema<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<TableSchema<'a>>>(CreateCommand::VT_SCHEMA, None).unwrap()
  }
  #[inline]
  pub fn engine(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CreateCommand::VT_ENGINE, None).unwrap()
  }
}

pub struct CreateCommandArgs<'a> {
    pub schema: Option<flatbuffers::WIPOffset<TableSchema<'a >>>,
    pub engine: Option<flatbuffers::WIPOffset<&'a  str>>,
}
impl<'a> Default for CreateCommandArgs<'a> {
    #[inline]
    fn default() -> Self {
        CreateCommandArgs {
            schema: None, // required field
            engine: None, // required field
        }
    }
}
pub struct CreateCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> CreateCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<TableSchema<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TableSchema>>(CreateCommand::VT_SCHEMA, schema);
  }
  #[inline]
  pub fn add_engine(&mut self, engine: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CreateCommand::VT_ENGINE, engine);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> CreateCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    CreateCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CreateCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, CreateCommand::VT_SCHEMA,"schema");
    self.fbb_.required(o, CreateCommand::VT_ENGINE,"engine");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum TableSchemaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct TableSchema<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TableSchema<'a> {
    type Inner = TableSchema<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> TableSchema<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TableSchema {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TableSchemaArgs<'args>) -> flatbuffers::WIPOffset<TableSchema<'bldr>> {
      let mut builder = TableSchemaBuilder::new(_fbb);
      if let Some(x) = args.fields { builder.add_fields(x); }
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_id(args.id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<TableSchema<'wr_to>> {
      let fields = { let mut tmp = vec!(); for x in self.fields() { tmp.push(x.write_to(_fbb)) }  let tmp_len = tmp.len();  _fbb.start_vector::<flatbuffers::WIPOffset<TableSchema>>(tmp_len);    for x in tmp { _fbb.push(x); }  _fbb.end_vector(tmp_len)};
      let name = _fbb.create_string(self.name());
      let id = self.id();
      let mut builder = TableSchemaBuilder::new(_fbb);
      builder.add_fields(fields);
      builder.add_name(name);
      builder.add_id(id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_FIELDS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(TableSchema::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TableSchema::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FieldDescription<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FieldDescription<'a>>>>>(TableSchema::VT_FIELDS, None).unwrap()
  }
}

pub struct TableSchemaArgs<'a> {
    pub id: u16,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FieldDescription<'a >>>>>,
}
impl<'a> Default for TableSchemaArgs<'a> {
    #[inline]
    fn default() -> Self {
        TableSchemaArgs {
            id: 0,
            name: None, // required field
            fields: None, // required field
        }
    }
}
pub struct TableSchemaBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TableSchemaBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(TableSchema::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableSchema::VT_NAME, name);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FieldDescription<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TableSchema::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TableSchemaBuilder<'a, 'b> {
    let start = _fbb.start_table();
    TableSchemaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TableSchema<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, TableSchema::VT_NAME,"name");
    self.fbb_.required(o, TableSchema::VT_FIELDS,"fields");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum ImmediateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Immediate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Immediate<'a> {
    type Inner = Immediate<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Immediate<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Immediate {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ImmediateArgs<'args>) -> flatbuffers::WIPOffset<Immediate<'bldr>> {
      let mut builder = ImmediateBuilder::new(_fbb);
      builder.add_num(args.num);
      if let Some(x) = args.blob { builder.add_blob(x); }
      builder.add_type_(args.type_);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<Immediate<'wr_to>> {
      let num = self.num();
      let blob =  { match self.blob() { Some(u) => Some(_fbb.create_vector_direct(u)), _ => None } };
      let type_ = self.type_();
      let mut builder = ImmediateBuilder::new(_fbb);
      builder.add_num(num);
      if let Some(u) = blob { builder.add_blob(u); } 
      builder.add_type_(type_);
      builder.finish()
    }

    pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
    pub const VT_BLOB: flatbuffers::VOffsetT = 6;
    pub const VT_NUM: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn type_(&self) -> FieldType {
    self._tab.get::<FieldType>(Immediate::VT_TYPE_, Some(FieldType::Blob)).unwrap()
  }
  #[inline]
  pub fn blob(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Immediate::VT_BLOB, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn num(&self) -> u64 {
    self._tab.get::<u64>(Immediate::VT_NUM, Some(0)).unwrap()
  }
}

pub struct ImmediateArgs<'a> {
    pub type_: FieldType,
    pub blob: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub num: u64,
}
impl<'a> Default for ImmediateArgs<'a> {
    #[inline]
    fn default() -> Self {
        ImmediateArgs {
            type_: FieldType::Blob,
            blob: None,
            num: 0,
        }
    }
}
pub struct ImmediateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ImmediateBuilder<'a, 'b> {
  #[inline]
  pub fn add_type_(&mut self, type_: FieldType) {
    self.fbb_.push_slot::<FieldType>(Immediate::VT_TYPE_, type_, FieldType::Blob);
  }
  #[inline]
  pub fn add_blob(&mut self, blob: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Immediate::VT_BLOB, blob);
  }
  #[inline]
  pub fn add_num(&mut self, num: u64) {
    self.fbb_.push_slot::<u64>(Immediate::VT_NUM, num, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ImmediateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    ImmediateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Immediate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FieldDescriptionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FieldDescription<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FieldDescription<'a> {
    type Inner = FieldDescription<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FieldDescription<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FieldDescription {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FieldDescriptionArgs<'args>) -> flatbuffers::WIPOffset<FieldDescription<'bldr>> {
      let mut builder = FieldDescriptionBuilder::new(_fbb);
      if let Some(x) = args.name { builder.add_name(x); }
      builder.add_size_(args.size_);
      builder.add_type_(args.type_);
      builder.add_id(args.id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<FieldDescription<'wr_to>> {
      let name = _fbb.create_string(self.name());
      let size_ = self.size_();
      let type_ = self.type_();
      let id = self.id();
      let mut builder = FieldDescriptionBuilder::new(_fbb);
      builder.add_name(name);
      builder.add_size_(size_);
      builder.add_type_(type_);
      builder.add_id(id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_NAME: flatbuffers::VOffsetT = 6;
    pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
    pub const VT_SIZE_: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn id(&self) -> u8 {
    self._tab.get::<u8>(FieldDescription::VT_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn name(&self) -> &'a str {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FieldDescription::VT_NAME, None).unwrap()
  }
  #[inline]
  pub fn type_(&self) -> FieldType {
    self._tab.get::<FieldType>(FieldDescription::VT_TYPE_, Some(FieldType::Blob)).unwrap()
  }
  #[inline]
  pub fn size_(&self) -> u16 {
    self._tab.get::<u16>(FieldDescription::VT_SIZE_, Some(0)).unwrap()
  }
}

pub struct FieldDescriptionArgs<'a> {
    pub id: u8,
    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub type_: FieldType,
    pub size_: u16,
}
impl<'a> Default for FieldDescriptionArgs<'a> {
    #[inline]
    fn default() -> Self {
        FieldDescriptionArgs {
            id: 0,
            name: None, // required field
            type_: FieldType::Blob,
            size_: 0,
        }
    }
}
pub struct FieldDescriptionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldDescriptionBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u8) {
    self.fbb_.push_slot::<u8>(FieldDescription::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FieldDescription::VT_NAME, name);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: FieldType) {
    self.fbb_.push_slot::<FieldType>(FieldDescription::VT_TYPE_, type_, FieldType::Blob);
  }
  #[inline]
  pub fn add_size_(&mut self, size_: u16) {
    self.fbb_.push_slot::<u16>(FieldDescription::VT_SIZE_, size_, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldDescriptionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldDescriptionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FieldDescription<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FieldDescription::VT_NAME,"name");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DropCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DropCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DropCommand<'a> {
    type Inner = DropCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DropCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DropCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DropCommandArgs) -> flatbuffers::WIPOffset<DropCommand<'bldr>> {
      let mut builder = DropCommandBuilder::new(_fbb);
      builder.add_id(args.id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<DropCommand<'wr_to>> {
      let id = self.id();
      let mut builder = DropCommandBuilder::new(_fbb);
      builder.add_id(id);
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> u16 {
    self._tab.get::<u16>(DropCommand::VT_ID, Some(0)).unwrap()
  }
}

pub struct DropCommandArgs {
    pub id: u16,
}
impl<'a> Default for DropCommandArgs {
    #[inline]
    fn default() -> Self {
        DropCommandArgs {
            id: 0,
        }
    }
}
pub struct DropCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DropCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u16) {
    self.fbb_.push_slot::<u16>(DropCommand::VT_ID, id, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DropCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DropCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DropCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InsertCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InsertCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InsertCommand<'a> {
    type Inner = InsertCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InsertCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InsertCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InsertCommandArgs<'args>) -> flatbuffers::WIPOffset<InsertCommand<'bldr>> {
      let mut builder = InsertCommandBuilder::new(_fbb);
      if let Some(x) = args.row { builder.add_row(x); }
      builder.add_table_id(args.table_id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<InsertCommand<'wr_to>> {
      let row = self.row().write_to(_fbb);
      let table_id = self.table_id();
      let mut builder = InsertCommandBuilder::new(_fbb);
      builder.add_row(row);
      builder.add_table_id(table_id);
      builder.finish()
    }

    pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_ROW: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn table_id(&self) -> u16 {
    self._tab.get::<u16>(InsertCommand::VT_TABLE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn row(&self) -> Row<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Row<'a>>>(InsertCommand::VT_ROW, None).unwrap()
  }
}

pub struct InsertCommandArgs<'a> {
    pub table_id: u16,
    pub row: Option<flatbuffers::WIPOffset<Row<'a >>>,
}
impl<'a> Default for InsertCommandArgs<'a> {
    #[inline]
    fn default() -> Self {
        InsertCommandArgs {
            table_id: 0,
            row: None, // required field
        }
    }
}
pub struct InsertCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InsertCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: u16) {
    self.fbb_.push_slot::<u16>(InsertCommand::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_row(&mut self, row: flatbuffers::WIPOffset<Row<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Row>>(InsertCommand::VT_ROW, row);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InsertCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InsertCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InsertCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, InsertCommand::VT_ROW,"row");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RowOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Row<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Row<'a> {
    type Inner = Row<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Row<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Row {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RowArgs<'args>) -> flatbuffers::WIPOffset<Row<'bldr>> {
      let mut builder = RowBuilder::new(_fbb);
      if let Some(x) = args.data { builder.add_data(x); }
      builder.add_len(args.len);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<Row<'wr_to>> {
      let data = { let mut tmp = vec!(); for x in self.data() { tmp.push(x.write_to(_fbb)) }  let tmp_len = tmp.len();  _fbb.start_vector::<flatbuffers::WIPOffset<Row>>(tmp_len);    for x in tmp { _fbb.push(x); }  _fbb.end_vector(tmp_len)};
      let len = self.len();
      let mut builder = RowBuilder::new(_fbb);
      builder.add_data(data);
      builder.add_len(len);
      builder.finish()
    }

    pub const VT_LEN: flatbuffers::VOffsetT = 4;
    pub const VT_DATA: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn len(&self) -> u16 {
    self._tab.get::<u16>(Row::VT_LEN, Some(0)).unwrap()
  }
  #[inline]
  pub fn data(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Immediate<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Immediate<'a>>>>>(Row::VT_DATA, None).unwrap()
  }
}

pub struct RowArgs<'a> {
    pub len: u16,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Immediate<'a >>>>>,
}
impl<'a> Default for RowArgs<'a> {
    #[inline]
    fn default() -> Self {
        RowArgs {
            len: 0,
            data: None, // required field
        }
    }
}
pub struct RowBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RowBuilder<'a, 'b> {
  #[inline]
  pub fn add_len(&mut self, len: u16) {
    self.fbb_.push_slot::<u16>(Row::VT_LEN, len, 0);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Immediate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Row::VT_DATA, data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RowBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Row<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Row::VT_DATA,"data");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum DeleteCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct DeleteCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DeleteCommand<'a> {
    type Inner = DeleteCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> DeleteCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DeleteCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DeleteCommandArgs<'args>) -> flatbuffers::WIPOffset<DeleteCommand<'bldr>> {
      let mut builder = DeleteCommandBuilder::new(_fbb);
      if let Some(x) = args.filter { builder.add_filter(x); }
      builder.add_max(args.max);
      builder.add_table_id(args.table_id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<DeleteCommand<'wr_to>> {
      let filter =  { match self.filter() { Some(u) => Some(u.write_to(_fbb)), _ => None } };
      let max = self.max();
      let table_id = self.table_id();
      let mut builder = DeleteCommandBuilder::new(_fbb);
      if let Some(u) = filter { builder.add_filter(u); } 
      builder.add_max(max);
      builder.add_table_id(table_id);
      builder.finish()
    }

    pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FILTER: flatbuffers::VOffsetT = 6;
    pub const VT_MAX: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn table_id(&self) -> u16 {
    self._tab.get::<u16>(DeleteCommand::VT_TABLE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn filter(&self) -> Option<Filter<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Filter<'a>>>(DeleteCommand::VT_FILTER, None)
  }
  #[inline]
  pub fn max(&self) -> u16 {
    self._tab.get::<u16>(DeleteCommand::VT_MAX, Some(0)).unwrap()
  }
}

pub struct DeleteCommandArgs<'a> {
    pub table_id: u16,
    pub filter: Option<flatbuffers::WIPOffset<Filter<'a >>>,
    pub max: u16,
}
impl<'a> Default for DeleteCommandArgs<'a> {
    #[inline]
    fn default() -> Self {
        DeleteCommandArgs {
            table_id: 0,
            filter: None,
            max: 0,
        }
    }
}
pub struct DeleteCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DeleteCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: u16) {
    self.fbb_.push_slot::<u16>(DeleteCommand::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(DeleteCommand::VT_FILTER, filter);
  }
  #[inline]
  pub fn add_max(&mut self, max: u16) {
    self.fbb_.push_slot::<u16>(DeleteCommand::VT_MAX, max, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DeleteCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    DeleteCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DeleteCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum QueryCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct QueryCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for QueryCommand<'a> {
    type Inner = QueryCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> QueryCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        QueryCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args QueryCommandArgs<'args>) -> flatbuffers::WIPOffset<QueryCommand<'bldr>> {
      let mut builder = QueryCommandBuilder::new(_fbb);
      if let Some(x) = args.filter { builder.add_filter(x); }
      builder.add_max_results(args.max_results);
      builder.add_table_id(args.table_id);
      builder.add_sort_field(args.sort_field);
      builder.add_sort(args.sort);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<QueryCommand<'wr_to>> {
      let filter =  { match self.filter() { Some(u) => Some(u.write_to(_fbb)), _ => None } };
      let max_results = self.max_results();
      let table_id = self.table_id();
      let sort_field = self.sort_field();
      let sort = self.sort();
      let mut builder = QueryCommandBuilder::new(_fbb);
      if let Some(u) = filter { builder.add_filter(u); } 
      builder.add_max_results(max_results);
      builder.add_table_id(table_id);
      builder.add_sort_field(sort_field);
      builder.add_sort(sort);
      builder.finish()
    }

    pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_MAX_RESULTS: flatbuffers::VOffsetT = 6;
    pub const VT_SORT: flatbuffers::VOffsetT = 8;
    pub const VT_SORT_FIELD: flatbuffers::VOffsetT = 10;
    pub const VT_FILTER: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn table_id(&self) -> u16 {
    self._tab.get::<u16>(QueryCommand::VT_TABLE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn max_results(&self) -> u16 {
    self._tab.get::<u16>(QueryCommand::VT_MAX_RESULTS, Some(0)).unwrap()
  }
  #[inline]
  pub fn sort(&self) -> Sort {
    self._tab.get::<Sort>(QueryCommand::VT_SORT, Some(Sort::None)).unwrap()
  }
  #[inline]
  pub fn sort_field(&self) -> u8 {
    self._tab.get::<u8>(QueryCommand::VT_SORT_FIELD, Some(0)).unwrap()
  }
  #[inline]
  pub fn filter(&self) -> Option<Filter<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Filter<'a>>>(QueryCommand::VT_FILTER, None)
  }
}

pub struct QueryCommandArgs<'a> {
    pub table_id: u16,
    pub max_results: u16,
    pub sort: Sort,
    pub sort_field: u8,
    pub filter: Option<flatbuffers::WIPOffset<Filter<'a >>>,
}
impl<'a> Default for QueryCommandArgs<'a> {
    #[inline]
    fn default() -> Self {
        QueryCommandArgs {
            table_id: 0,
            max_results: 0,
            sort: Sort::None,
            sort_field: 0,
            filter: None,
        }
    }
}
pub struct QueryCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> QueryCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: u16) {
    self.fbb_.push_slot::<u16>(QueryCommand::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_max_results(&mut self, max_results: u16) {
    self.fbb_.push_slot::<u16>(QueryCommand::VT_MAX_RESULTS, max_results, 0);
  }
  #[inline]
  pub fn add_sort(&mut self, sort: Sort) {
    self.fbb_.push_slot::<Sort>(QueryCommand::VT_SORT, sort, Sort::None);
  }
  #[inline]
  pub fn add_sort_field(&mut self, sort_field: u8) {
    self.fbb_.push_slot::<u8>(QueryCommand::VT_SORT_FIELD, sort_field, 0);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(QueryCommand::VT_FILTER, filter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> QueryCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    QueryCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<QueryCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum FieldUpdateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct FieldUpdate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FieldUpdate<'a> {
    type Inner = FieldUpdate<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> FieldUpdate<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        FieldUpdate {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args FieldUpdateArgs) -> flatbuffers::WIPOffset<FieldUpdate<'bldr>> {
      let mut builder = FieldUpdateBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      builder.add_value_type(args.value_type);
      builder.add_field_id(args.field_id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<FieldUpdate<'wr_to>> {
      let value = self.value_write_to(_fbb);
      let value_type = self.value_type();
      let field_id = self.field_id();
      let mut builder = FieldUpdateBuilder::new(_fbb);
      value.map(|u| builder.add_value(u));
      builder.add_value_type(value_type);
      builder.add_field_id(field_id);
      builder.finish()
    }

    pub const VT_FIELD_ID: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn field_id(&self) -> u8 {
    self._tab.get::<u8>(FieldUpdate::VT_FIELD_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn value_type(&self) -> UpdateValue {
    self._tab.get::<UpdateValue>(FieldUpdate::VT_VALUE_TYPE, Some(UpdateValue::NONE)).unwrap()
  }
  #[inline]
  pub fn value(&self) -> flatbuffers::Table<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(FieldUpdate::VT_VALUE, None).unwrap()
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_immediate(&self) -> Option<Immediate<'a>> {
    if self.value_type() == UpdateValue::immediate {
      Some(Immediate::init_from_table( self.value()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_as_reference(&self) -> Option<TableReference<'a>> {
    if self.value_type() == UpdateValue::reference {
      Some(TableReference::init_from_table( self.value()))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn value_write_to<'wr_to>(&self, _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>> {
    if self.value_type() == UpdateValue::immediate {
      return Some(Immediate::init_from_table(self.value()).write_to(_fbb).as_union_value());
    }
    if self.value_type() == UpdateValue::reference {
      return Some(TableReference::init_from_table(self.value()).write_to(_fbb).as_union_value());
    }
    None
  }

}

pub struct FieldUpdateArgs {
    pub field_id: u8,
    pub value_type: UpdateValue,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for FieldUpdateArgs {
    #[inline]
    fn default() -> Self {
        FieldUpdateArgs {
            field_id: 0,
            value_type: UpdateValue::NONE,
            value: None, // required field
        }
    }
}
pub struct FieldUpdateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> FieldUpdateBuilder<'a, 'b> {
  #[inline]
  pub fn add_field_id(&mut self, field_id: u8) {
    self.fbb_.push_slot::<u8>(FieldUpdate::VT_FIELD_ID, field_id, 0);
  }
  #[inline]
  pub fn add_value_type(&mut self, value_type: UpdateValue) {
    self.fbb_.push_slot::<UpdateValue>(FieldUpdate::VT_VALUE_TYPE, value_type, UpdateValue::NONE);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FieldUpdate::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldUpdateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    FieldUpdateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FieldUpdate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, FieldUpdate::VT_VALUE,"value");
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UpdateCommandOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UpdateCommand<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateCommand<'a> {
    type Inner = UpdateCommand<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UpdateCommand<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UpdateCommand {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UpdateCommandArgs<'args>) -> flatbuffers::WIPOffset<UpdateCommand<'bldr>> {
      let mut builder = UpdateCommandBuilder::new(_fbb);
      if let Some(x) = args.updates { builder.add_updates(x); }
      if let Some(x) = args.filter { builder.add_filter(x); }
      builder.add_table_id(args.table_id);
      builder.finish()
    }

    #[allow(unused_mut)]
    pub fn write_to<'wr_to>(&self,
          _fbb: &mut flatbuffers::FlatBufferBuilder<'wr_to>) -> flatbuffers::WIPOffset<UpdateCommand<'wr_to>> {
      let updates = { let mut tmp = vec!(); for x in self.updates() { tmp.push(x.write_to(_fbb)) }  let tmp_len = tmp.len();  _fbb.start_vector::<flatbuffers::WIPOffset<UpdateCommand>>(tmp_len);    for x in tmp { _fbb.push(x); }  _fbb.end_vector(tmp_len)};
      let filter = self.filter().write_to(_fbb);
      let table_id = self.table_id();
      let mut builder = UpdateCommandBuilder::new(_fbb);
      builder.add_updates(updates);
      builder.add_filter(filter);
      builder.add_table_id(table_id);
      builder.finish()
    }

    pub const VT_TABLE_ID: flatbuffers::VOffsetT = 4;
    pub const VT_FILTER: flatbuffers::VOffsetT = 6;
    pub const VT_UPDATES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn table_id(&self) -> u16 {
    self._tab.get::<u16>(UpdateCommand::VT_TABLE_ID, Some(0)).unwrap()
  }
  #[inline]
  pub fn filter(&self) -> Filter<'a> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Filter<'a>>>(UpdateCommand::VT_FILTER, None).unwrap()
  }
  #[inline]
  pub fn updates(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FieldUpdate<'a>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<FieldUpdate<'a>>>>>(UpdateCommand::VT_UPDATES, None).unwrap()
  }
}

pub struct UpdateCommandArgs<'a> {
    pub table_id: u16,
    pub filter: Option<flatbuffers::WIPOffset<Filter<'a >>>,
    pub updates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<FieldUpdate<'a >>>>>,
}
impl<'a> Default for UpdateCommandArgs<'a> {
    #[inline]
    fn default() -> Self {
        UpdateCommandArgs {
            table_id: 0,
            filter: None, // required field
            updates: None, // required field
        }
    }
}
pub struct UpdateCommandBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateCommandBuilder<'a, 'b> {
  #[inline]
  pub fn add_table_id(&mut self, table_id: u16) {
    self.fbb_.push_slot::<u16>(UpdateCommand::VT_TABLE_ID, table_id, 0);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<Filter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Filter>>(UpdateCommand::VT_FILTER, filter);
  }
  #[inline]
  pub fn add_updates(&mut self, updates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FieldUpdate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateCommand::VT_UPDATES, updates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateCommandBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateCommandBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateCommand<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, UpdateCommand::VT_FILTER,"filter");
    self.fbb_.required(o, UpdateCommand::VT_UPDATES,"updates");
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_packet<'a>(buf: &'a [u8]) -> Packet<'a> {
  flatbuffers::get_root::<Packet<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_packet<'a>(buf: &'a [u8]) -> Packet<'a> {
  flatbuffers::get_size_prefixed_root::<Packet<'a>>(buf)
}

#[inline]
pub fn finish_packet_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Packet<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_packet_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Packet<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
